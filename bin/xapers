#!/usr/bin/env python

import os
import sys
import xapers
import xapers.cli
import xapers.source
import logging
import argparse

########################################################################

# combine a list of terms with spaces between, so that simple queries
# don't have to be quoted at the shell level.


def make_query_string(terms, require=True):
    string = str.join(' ', terms)
    if string == '':
        if require:
            logging.error("Must specify a search term.")
            sys.exit(1)
        else:
            string = '*'
    return string


def import_nci():
    try:
        import xapers.nci
    except ImportError:
        logging.error( "The python-urwid package is not installed.")
        logging.error("Please install to be able to use the curses UI.")
        sys.exit(1)

########################################################################

epilog = """
The xapers document store is specified by the XAPERS_ROOT environment
variable, or defaults to '~/.xapers/docs' if not specified (the
directory is allowed to be a symlink).
"""

def_search_terms = """
Free-form text to match against indexed document
text, or the following prefixes can be used to match against
specific document metadata:
    id:<docid>               Xapers document id
    author:<string>          string in authors (also a:)
    title:<string>           string in title (also t:)
    tag:<tag>                specific user tags
    <source>:<id>            specific sid string
    source:<lib>             specific source
    key:<key>                specific bibtex citation key

The string '*' will match all documents.
"""

def_source = """
This is a URL, a source ID string of the form
'<source>:<id>', or a bibtex file
"""

########################################################################

if __name__ == '__main__':

    # create the top-level parser
    parser = argparse.ArgumentParser(epilog=epilog)

    # global options
    parser.add_argument('--version', action='version', version='Ha!')
    parser.add_argument('-v', '--verbose', action='count', default=0,
                        help='increase verbosity. This is repeatable')
    xroot = os.getenv('XAPERS_ROOT',
                      os.path.join('~', '.xapers', 'docs'))
    parser.add_argument('--xroot', help='path to xapers root', default=xroot)

    # add subcommands
    subparsers = parser.add_subparsers(dest="cmd", help='sub-command help')

    # add
    hmsg = 'Add a new document or update existing. '\
        'If provided, search should match a single document'
    # from py3.2, you can use parameter aliases=['a'] in the next line to
    # add subcommand aliases. If you feel this is a requirement one can locally
    # ship a backport.
    parser_add = subparsers.add_parser('add', help=hmsg)

    parser_add.add_argument('search')
    parser_add.add_argument(
        '--source', help='source for retrieving bibtex. ' + def_source)
    parser_add.add_argument(
        '--file', dest='infile', help='file to index and archive')
    parser_add.add_argument('--tag', metavar='tag', nargs='*',
                            help='initial tags',
                            default=['new'])
    parser_add.add_argument('--prompt', action='store_true',
                            help='prompt for unspecified options')
    parser_add.add_argument('--view', action='store_true',
                            help='view entry after adding')
    # delete
    parser_delete = subparsers.add_parser(
        'delete', help='Delete documents from database')
    parser_delete.add_argument('search')
    parser_delete.add_argument('--noprompt', action='store_true',
                               help='do not prompt to confirm deletion')
    # restore
    parser_restore = subparsers.add_parser(
        'restore', help='Restore database from xapers root')
    # update-all
    parser_update = subparsers.add_parser(
        'update', help='Update all documents')
    # tag
    # TODO: add validator that ensures all tags are prefixed correctly
    parser_tag = subparsers.add_parser('tag', help='Add/remove tags')
    parser_tag.add_argument('tags', metavar='tag', nargs='+')
    parser_tag.add_argument('search')
    # search
    parser_search = subparsers.add_parser(
        'search', help='Search for documents')
    parser_search.add_argument('search')
    parser_search.add_argument('--limit', type=int,
                               help='limit number of results returned',
                               default=20)
    parser_search.add_argument('--output',
                               choices=['summary', 'bibtex', 'tags',
                                        'sources', 'keys', 'files'],
                               help='output format',
                               default='summary')
    # bibtex
    hmsg = 'Short for \"search --output=bibtex\"'
    parser_bibtex = subparsers.add_parser('bibtex', help=hmsg)
    parser_bibtex.add_argument('search')
    # show
    parser_show = subparsers.add_parser(
        'show', help='View search in curses UI')
    parser_show.add_argument('search')
    # count
    parser_count = subparsers.add_parser('count', help='Count matches')
    parser_count.add_argument('search')
    # export
    hmsg = 'Export documents to a directory of files named for document titles'
    parser_export = subparsers.add_parser('export', help=hmsg)
    parser_export.add_argument('dir')  # TODO: check if valid dir HERE!
    parser_export.add_argument('search')
    # sources
    parser_sources = subparsers.add_parser(
        'sources', help='List available sources')
    # source2bib
    hmsg = 'retrieve bibtex for source and 70 print to stdout'
    parser_source2bib = subparsers.add_parser('source2bib', help=hmsg)
    parser_source2bib.add_argument('source', help='source. ' + def_source)
    # scandoc
    parser_scandoc = subparsers.add_parser(
        'scandoc', help='Scan a file for source IDs')
    parser_scandoc.add_argument('file')  # TODO: check if its a valid file

    # parse arguments and handle errors
    args = parser.parse_args()

    # define some global variables
    xroot = os.path.expanduser(args.xroot)
    cmd = args.cmd

    # set up the verbosity level of the logging system
    loglevel = {
        0: logging.WARNING,
        1: logging.INFO,
        2: logging.DEBUG,
    }[min(2, args.verbose)]
    # set up logging
    logging.basicConfig(level=loglevel,
                        format='%(levelname)s: %(message)s')

    logging.debug('command line parameter: %s' % args)

    ########################################
    if cmd == 'add':
        cli = xapers.cli.UI(xroot)

        # The original behavior can be simulated with a more complicated
        # parser argument for 'search'
        # query_string = make_query_string(sys.argv[argc:])
        query_string = args.search

        try:
            docid = cli.add(
                query_string, infile=args.infile, source=args.source,
                tags=args.tags, prompt=args.prompt)
        except KeyboardInterrupt:
            sys.exit(1)

        # dereference the cli object so that the database is flushed
        # FIXME: is there a better way to handle this?
        cli = None

        if args.view and docid:
            import_nci()
            xapers.nci.UI(xroot, cmd=['search', 'id:' + docid])

    ########################################
    elif cmd == 'update-all':
        cli = xapers.cli.UI(xroot)
        cli.update_all()

    ########################################
    elif cmd == 'delete':

        # The original behavior can be simulated with a more complicated
        # parser argument for 'search'
        # query_string = make_query_string(sys.argv[argc:])
        query_string = args.search

        cli = xapers.cli.UI(xroot)
        cli.delete(query_string, prompt=not args.noprompt)

    ########################################
    elif cmd in ['search', 'bibtex']:
        cli = xapers.cli.UI(xroot)

        if cmd == 'bibtex':
            args.output = 'bibtex'

        query_string = args.search
        try:
            cli.search(query_string, oformat=args.output, limit=args.limit)
        except KeyboardInterrupt:
            sys.exit(1)

    ########################################
    elif cmd == 'show':
        import_nci()

        query_string = args.search

        try:
            xapers.nci.UI(xroot, cmd=['search', query_string])
        except KeyboardInterrupt:
            sys.exit(1)

    ########################################
    elif cmd == 'tag':
        cli = xapers.cli.UI(xroot)

        add_tags = []
        remove_tags = []

        for tag in args.tags:
            if tag[0] == '+':
                add_tags.append(tag[1:])
            elif tag[0] == '-':
                remove_tags.append(tag[1:])

        # TODO: these two tests should go into a custom
        # argparse action
        if not add_tags and not remove_tags:
            logging.error("Must specify tags to add or remove.")
            sys.exit(1)

        if '' in add_tags:
            logging.error("Null tags not allowed.")
            sys.exit(1)

        query_string = args.search

        # TODO: this should really go into the lib, not some cli code!
        cli.tag(query_string, add_tags, remove_tags)

    ########################################
    # TODO: whats this? there is no documented subcommand like this!
    # This seems to be some debugging code?
    elif cmd in ['dumpterms']:
        cli = xapers.cli.UI(xroot)
        query = make_query_string(sys.argv[2:], require=False)
        cli.dumpterms(query)

    ########################################
    # TODO: whats this? there is no documented subcommand like this!
    # This seems to be some debugging code?
    elif cmd in ['maxid']:
        db = xapers.cli.initdb(xroot)
        docid = 0
        for doc in db.search('*'):
            docid = max(docid, int(doc.docid))
        print 'id:%d' % docid

    ########################################
    elif cmd == 'count':
        cli = xapers.cli.UI(xroot)
        # query = make_query_string(sys.argv[2:], require=False)
        query_string = args.search
        # TODO: this should really go into the lib, not some cli code!
        cli.count(query_string)

    ########################################
    elif cmd == 'export':
        cli = xapers.cli.UI(xroot)
        # query = make_query_string(sys.argv[3:])
        query_string = args.search
        # TODO: this should really go into the lib, not some cli code!
        cli.export(args.dir, query_string)

    ########################################
    elif cmd == 'restore':
        cli = xapers.cli.UI(xroot)
        cli.restore()

    ########################################
    elif cmd == 'sources':
        for source in xapers.source.list_sources():
            print source

    ########################################
    elif cmd == 'source2bib':

        try:
            smod = xapers.source.get_source(args.source)
        except xapers.source.SourceError as e:
            logging.exception(e)
            sys.exit(1)

        try:
            logging.info("Retrieving bibtex...")
            bibtex = smod.get_bibtex()
            logging.info("done.")
        except Exception, e:
            logging.error("Could not retrieve bibtex:")
            logging.exception(e)
            sys.exit(1)

        try:
            print xapers.bibtex.Bibtex(bibtex)[0].as_string()
        except Exception, e:
            logging.error("Error parsing bibtex: %s")
            logging.exception(e)
            logging.error("Outputting raw...")
            print bibtex
            sys.exit(1)

    ########################################
    elif cmd == 'scandoc':
        infile = args.file
        sources = xapers.source.scan_for_sources(infile)
        for ss in sources:
            print "%s" % (ss)
